package solved_ac_step.class3;
import java.io.*;

public class S1_6064 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        /*
        카잉 달력이 뭔가?
        M과 N이 주어지고 x y는 1씩 증가하다가
        마지막 증가한 값이 M또는 N과 같다면, 그다음 값은 1부터 다시 시작
        다만 이제 x = M x = N이 되는 경우 세상의 종말이 다가오는 것이다.

        그냥 세는 방법은?
        N은 40000보다 작고, M은 1보다 크면 제한이 없다.
        직접 하나씩 센다고 하면 시간 복잡도는 어떻게 될까?
        1억은 충분히 넘을 수 있을 거 같다. 불가능.

        M = 5 N = 7을 가정해보자.
        1 1  2 2 ... 5 5  (M초기화) 1 6   2 7  (N초기화) 3 1   4 2   5 3
        1 4   2 5   3 6   4 7   5 1   1 2   2  3

        첫 초기화 시엔 초기화 된 값만큼 차이가 나다가
        그다음 초기화되면 더 큰값에서 작은 값 뺀 만큼 차이가 난다.
        그래서 차이가 5 .. 2(=7-5) .. 3(5-2)... 이렇게 난다.
        당연히 빼는 순서는 작은 값(예시에선 M), 큰 값(예시에선 N)
        이게 반복될 것이다.
        5개 (M 초기화) 2개 (N 초기화) 3개 (M초기화) 4개 (N초기화)
        이제 규칙이 보이는 것 같다.
        M과 N이 한번씩 초기화된 시점은 당연하게 더 큰값을 가지는 횟수만큼일것.
        차이의 변화는
        작은 값 , A(=큰값 - 작은값), B=(작은값 - A), C(=큰값 - B),...
        5, 2(=7-5), 3(=5-2), 4(=7-3), 1(5-4), 6(7-1)
        차이가 6이 나왔고, 이건 존재할 수가 없다. 이건 왜냐하면
        5가 두번 초기화되는 일이 발생했기 때문이다.
        차이가 1이고 5가 초기화되면 1 2 2 3 3 4 4 5 5 6 .. 이런것이다.
        7에 다다르기도 전에 5가 한 번 더 초기화된거다. 따라서 이 아이디어는 잘못됨.
        그래서 차이가 작은 값(여기선 M)보다 커지면 작은값에서 한번 빼도록 하는 건 어떨까?
        그렇게 되면 차이가 2번 바뀌면 횟수가 7번 돌았다는 걸 쓸 수 없다.
        그럼 반대로, 마지막 해가 나오려면 얼마나 걸리는지를 봐봤다.




        */
    }
}
